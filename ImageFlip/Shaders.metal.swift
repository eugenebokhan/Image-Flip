
// This file is autogenerated, do not edit it
import Alloy


internal class TextureFlip {

  internal let deviceSupportsNonuniformThreadgroups: Bool

  internal let pipelineState: MTLComputePipelineState

  internal init(library: MTLLibrary) throws {
    let constantValues = MTLFunctionConstantValues()
    self.deviceSupportsNonuniformThreadgroups = library.device.supports(feature: .nonUniformThreadgroups)
    constantValues.set(self.deviceSupportsNonuniformThreadgroups, at: 0)
    self.pipelineState = try library.computePipelineState(function: "textureFlip", constants: constantValues)
  }

  internal func callAsFunction(source: MTLTexture, destination: MTLTexture, in commandBuffer: MTLCommandBuffer) {
    self.encode(source: source, destination: destination, in: commandBuffer)
  }
  internal func callAsFunction(source: MTLTexture, destination: MTLTexture, using encoder: MTLComputeCommandEncoder) {
    self.encode(source: source, destination: destination, using: encoder)
  }
  internal func encode(source: MTLTexture, destination: MTLTexture, in commandBuffer: MTLCommandBuffer) {
    commandBuffer.compute { encoder in
      encoder.label = "TextureFlip"
      self.encode(source: source, destination: destination, using: encoder)
    }
  }
  internal func encode(source: MTLTexture, destination: MTLTexture, using encoder: MTLComputeCommandEncoder) {
    let _threadgroupSize = self.pipelineState.max2dThreadgroupSize
    encoder.setTexture(source, index: 0)
    encoder.setTexture(destination, index: 1)

    if self.deviceSupportsNonuniformThreadgroups { encoder.dispatch2d(state: self.pipelineState, exactly: destination.size, threadgroupSize: _threadgroupSize) } else { encoder.dispatch2d(state: self.pipelineState, covering: destination.size, threadgroupSize: _threadgroupSize) }
  }

}

